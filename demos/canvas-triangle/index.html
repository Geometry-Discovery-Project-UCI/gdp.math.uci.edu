<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triangle</title>
    <script src="https://unpkg.com/fabric@5.0.0/dist/fabric.min.js"></script>
</head>
<style>
    html,
    body {
        height: 100%;
        width: 100%;
    }

    #canvas {
        border: 1px solid #ccc;
    }
</style>

<body>
    <canvas id="canvas" height="500" width="500"></canvas>
</body>
<script>
    const canvas = new fabric.Canvas("canvas");
    // create a polygon object
    var points = [{
        x: 2, y: 1
    }, {
        x: 1, y: 4
    }, {
        x: 4, y: 4
    }];
    const polygon = new fabric.Polygon(points, {
        left: 100,
        top: 100,
        fill: 'white',
        strokeWidth: 0.01,
        stroke: 'black',
        scaleX: 100,
        scaleY: 100,
        objectCaching: false,
        transparentCorners: false,
    });

    const line = new fabric.Line([1, 2, 30, 50], {
        left: 50,
        top: 50,
        stroke: 'black'
    });
    canvas.add(line);

    // define a function that can locate the controls.
    // this function will be used both for drawing and for interaction.
    function polygonPositionHandler(dim, finalMatrix, fabricObject) {
        const x = (fabricObject.points[this.pointIndex].x - fabricObject.pathOffset.x),
            y = (fabricObject.points[this.pointIndex].y - fabricObject.pathOffset.y);
        return fabric.util.transformPoint(
            { x: x, y: y },
            fabric.util.multiplyTransformMatrices(
                fabricObject.canvas.viewportTransform,
                fabricObject.calcTransformMatrix()
            )
        );
    }

    // define what the control does this function will be called on every mouse move after a control has been
    // clicked and is being dragged.
    // The function receive as argument the mouse event, the current trasnform object
    // and the current position in canvas coordinate
    // transform.target is a reference to the current object being transformed,
    function actionHandler(eventData, transform, x, y) {
        const polygon = transform.target,
            currentControl = polygon.controls[polygon.__corner],
            mouseLocalPosition = polygon.toLocalPoint(new fabric.Point(x, y), 'center', 'center'),
            polygonBaseSize = polygon._getNonTransformedDimensions(),
            size = polygon._getTransformedDimensions(0, 0),
            finalPointPosition = {
                x: mouseLocalPosition.x * polygonBaseSize.x / size.x + polygon.pathOffset.x,
                y: mouseLocalPosition.y * polygonBaseSize.y / size.y + polygon.pathOffset.y
            };
        polygon.points[currentControl.pointIndex] = finalPointPosition;
        return true;
    }

    // keep the polygon in the same position when we change its width/height/top/left.
    function anchorWrapper(anchorIndex, fn) {
        return function (eventData, transform, x, y) {
            var fabricObject = transform.target,
                absolutePoint = fabric.util.transformPoint({
                    x: (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x),
                    y: (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y),
                }, fabricObject.calcTransformMatrix()),
                actionPerformed = fn(eventData, transform, x, y),
                newDim = fabricObject._setPositionDimensions({}),
                polygonBaseSize = fabricObject._getNonTransformedDimensions(),
                newX = (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x) / polygonBaseSize.x,
                newY = (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y) / polygonBaseSize.y;
            fabricObject.setPositionByOrigin(absolutePoint, newX + 0.5, newY + 0.5);
            return actionPerformed;
        }
    }

    canvas.setActiveObject(polygon);
    polygon.cornerStyle = 'circle';
    polygon.cornerColor = 'rgba(0,0,0,0)';
    polygon.cornerSize = 20;
    polygon.controls = polygon.points.reduce(function (acc, point, index) {
        acc['p' + index] = new fabric.Control({
            positionHandler: polygonPositionHandler,
            actionHandler: anchorWrapper(index > 0 ? index - 1 : polygon.points.length - 1, actionHandler),
            actionName: 'modifyPolygon',
            pointIndex: index
        });
        return acc;
    }, {});
    polygon.hasBorders = false;
    canvas.add(polygon);
</script>

</html>